// SPDX-FileCopyrightText: 2021 Toucan Labs
//
// SPDX-License-Identifier: UNLICENSED

// If you encounter a vulnerability or an issue, please contact <security@toucan.earth> or visit security.toucan.earth
pragma solidity >=0.8.4 <=0.8.14;

import '@openzeppelin/contracts/access/Ownable.sol';

import '../interfaces/IPoolFilter.sol';
import '../interfaces/IToucanContractRegistry.sol';
import '../interfaces/IToucanCarbonOffsets.sol';

// Specific implementation of an external pool filter
// Allows for filtering based on Toucan compliant attributes
// Uses mappings instead of Struct nested arrays
contract PoolFilterAttributeMapping is Ownable, IPoolFilter {
    address public contractRegistry;

    uint64 public minimumVintageStartTime;

    // Attributes that can be included or excluded
    // false = attribute is a blacklisting/rejection criteria
    bool public regionsIsAcceptedMapping = false;
    mapping(string => bool) public regions;

    bool public standardsIsAcceptedMapping = false;
    mapping(string => bool) public standards;

    bool public methodologiesIsAcceptedMapping = false;
    mapping(string => bool) public methodologies;

    // ------------------------
    //      Admin functions
    // ------------------------

    function setToucanContractRegistry(address _address) public onlyOwner {
        contractRegistry = _address;
    }

    /// @dev WIP: Generic function to switch attributes mappings into either
    /// acceptance or rejection criteria
    /// Todo: turn into nested mappings to support future attributes
    function switchMapping(string memory _mappingName, bool accepted)
        public
        onlyOwner
    {
        if (strcmp(_mappingName, 'regions')) {
            accepted
                ? regionsIsAcceptedMapping = true
                : regionsIsAcceptedMapping = false;
        } else if (strcmp(_mappingName, 'standards')) {
            accepted
                ? standardsIsAcceptedMapping = true
                : standardsIsAcceptedMapping = false;
        } else if (strcmp(_mappingName, 'methodologies')) {
            accepted
                ? methodologiesIsAcceptedMapping = true
                : methodologiesIsAcceptedMapping = false;
        }
    }

    // Functions
    function makeRegionsIsAcceptedMapping() public onlyOwner {
        regionsIsAcceptedMapping = true;
    }

    function makeStandardsIsAcceptedMapping() public onlyOwner {
        standardsIsAcceptedMapping = true;
    }

    function makeMethodologiesIsAcceptedMapping() public onlyOwner {
        methodologiesIsAcceptedMapping = true;
    }

    function memcmp(bytes memory a, bytes memory b)
        internal
        pure
        returns (bool)
    {
        return (a.length == b.length) && (keccak256(a) == keccak256(b));
    }

    function strcmp(string memory a, string memory b)
        internal
        pure
        returns (bool)
    {
        return memcmp(bytes(a), bytes(b));
    }

    // Simple blacklisting function that does not support AttributeSets
    function blackListAttributes(
        bool addToList,
        string[] memory _regions,
        string[] memory _standards,
        string[] memory _methodologies
    ) public onlyOwner {
        for (uint256 i; i < _standards.length; ++i) {
            if (addToList == true) {
                regions[_regions[i]] = true;
            } else {
                regions[_regions[i]] = false;
            }
        }

        for (uint256 i; i < _methodologies.length; ++i) {
            if (addToList == true) {
                regions[_regions[i]] = true;
            } else {
                regions[_regions[i]] = false;
            }
        }

        //...
        //...
    }

    // Function can be updated (while keeping the same signature)
    function checkEligible(address erc20Addr)
        external
        view
        override
        returns (bool)
    {
        bool isToucanContract = IToucanContractRegistry(contractRegistry)
            .checkERC20(erc20Addr);

        if (isToucanContract) {
            require(
                checkAttributeMatching(erc20Addr) == true,
                'Toucan contract rejected, non-matching attributes'
            );
        }
        // If not Toucan native contract, check if address is whitelisted
        else {
            return false;
        }

        return true;
    }

    // ------------------------
    // Permissionless functions
    // ------------------------

    // Checks whether incoming project-vintage-ERC20 token matches the accepted criteria/attributes
    function checkAttributeMatching(address erc20Addr)
        public
        view
        returns (bool)
    {
        ProjectData memory projectData;
        VintageData memory vintageData;
        (projectData, vintageData) = IToucanCarbonOffsets(erc20Addr)
            .getAttributes();

        // Check if any one of the attributes is blacklisted
        // If mappings are set to "whitelist"-mode, require the opposite
        require(vintageData.startTime > minimumVintageStartTime);
        require(regions[projectData.region] == regionsIsAcceptedMapping);
        require(standards[projectData.standard] == standardsIsAcceptedMapping);
        require(
            methodologies[projectData.methodology] ==
                methodologiesIsAcceptedMapping
        );

        return true;
    }
}
