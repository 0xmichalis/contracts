// SPDX-FileCopyrightText: 2021 Toucan Labs
//
// SPDX-License-Identifier: UNLICENSED

// If you encounter a vulnerability or an issue, please contact <security@toucan.earth> or visit security.toucan.earth
pragma solidity >=0.8.4 <=0.8.14;

import '@openzeppelin/contracts/access/Ownable.sol';

import '../interfaces/IPoolFilter.sol';
import '../interfaces/IToucanContractRegistry.sol';
import './../ToucanCarbonOffsets.sol';

// Specific implementation of an external pool filter
// Allows for filtering based on Toucan compliant attributes
// Uses mappings instead of Struct nested arrays
contract PoolFilterAttributeStructs is Ownable, IPoolFilter {
    address public contractRegistry;

    mapping(address => bool) public whiteList;
    mapping(address => bool) public previouslyAcceptedContracts;

    // Describes the allowe attributes as arrays per set
    // Note: pids (project identifiers) probably not needed
    struct AttributeSet {
        string[] regions;
        string[] standards;
        string[] methodologies;
    }

    // All allowed sets
    AttributeSet[] allowedSets;

    // ------------------------
    //      Admin functions
    // ------------------------

    function setToucanContractRegistry(address _address) public onlyOwner {
        contractRegistry = _address;
    }

    // Function to add a single AttributeSet to allowedSets
    function addAttributeSet(
        string[] memory _regions,
        string[] memory _standards,
        string[] memory _methodologies
    ) public onlyOwner {
        AttributeSet memory set;

        set.regions = _regions;
        set.standards = _standards;
        set.methodologies = _methodologies;

        allowedSets.push(set);
    }

    // Shall give the owner the ability to remove certain attribute sets
    function removeAttributeSet(uint256 index) public onlyOwner {
        delete allowedSets[index];
    }

    // ------------------------
    // Permissionless functions
    // ------------------------

    // Function can be updated (while keeping the same signature)
    function checkEligible(address erc20Addr)
        external
        view
        override
        returns (bool)
    {
        bool isToucanContract = IToucanContractRegistry(contractRegistry)
            .checkERC20(erc20Addr);

        if (isToucanContract) {
            require(
                checkAttributeMatching(erc20Addr) == true,
                'Toucan contract rejected, non-matching attributes'
            );
        }
        // If not Toucan native contract, check if address is whitelisted
        else {
            return false;
        }

        return true;
    }

    // Checks whether incoming project-vintage-ERC20 token matches the accepted criteria/attributes
    function checkAttributeMatching(address erc20Addr)
        public
        view
        returns (bool)
    {
        // console.log("DEBUG checkAttributeMatching:", erc20Addr);
        /// @dev Querying the attributes from the incoming TCO2 token
        ProjectData memory projectData;
        (projectData, ) = ToucanCarbonOffsets(erc20Addr).getAttributes();

        // string memory s = projectData.standard;
        // string memory m = projectData.methodology;
        // string memory r = projectData.region;
        // console.log("DEBUG vintage,standard:", v, s);
        // console.log("DEBUG method, region:", m, projectData.region);

        // Corresponding match variables
        bool vMatch = false;
        bool rMatch = false;
        bool sMatch = false;
        bool mMatch = false;

        // Length of struct array
        uint256 setLen = allowedSets.length;

        // Here: For loop, looping through set array
        for (uint256 x; x < setLen; ++x) {
            // Every array might have a different length
            uint256 rlen = allowedSets[x].regions.length;
            uint256 slen = allowedSets[x].standards.length;
            uint256 mlen = allowedSets[x].methodologies.length;

            // Jump to next AttributeSet
            if (vMatch == false) continue;

            for (uint256 i; i < rlen; ++i) {
                // console.log("DEBUG regions:",i, allowedSets[x].regions[i]);

                if (
                    keccak256(abi.encodePacked(allowedSets[x].regions[i])) ==
                    keccak256(abi.encodePacked(projectData.region))
                ) {
                    // console.log("DEBUG: match in REGIONS in set:", x);
                    rMatch = true;
                    break;
                } else {
                    continue;
                }
            }

            // Jump to next AttributeSet
            if (rMatch == false) continue;

            for (uint256 i; i < slen; ++i) {
                // console.log("DEBUG standards:",i, allowedSets[x].standards[i]);

                if (
                    keccak256(abi.encodePacked(allowedSets[x].standards[i])) ==
                    keccak256(abi.encodePacked(projectData.standard))
                ) {
                    // console.log("DEBUG: match in STANDARDS in set:", x);
                    sMatch = true;
                    break;
                } else {
                    continue;
                }
            }

            // Jump to next AttributeSet
            if (sMatch == false) continue;

            for (uint256 i; i < mlen; ++i) {
                // console.log("DEBUG methodologies:",i, allowedSets[x].methodologies[i]);

                if (
                    keccak256(
                        abi.encodePacked(allowedSets[x].methodologies[i])
                    ) == keccak256(abi.encodePacked(projectData.standard))
                ) {
                    // console.log("DEBUG: match in METHODOLOGIES in set:", x);
                    mMatch = true;
                    break;
                } else {
                    continue;
                }
            }

            // Final check if all attributes are matching
            if (vMatch && rMatch && sMatch && mMatch) {
                return true;
            } else continue;
        }
        // no matches found during search
        return false;
    }
}
